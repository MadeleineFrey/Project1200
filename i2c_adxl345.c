#include <pic32mx.h>
#include <stdint.h>
#include <stdbool.h>
#include "adxl.h"
#include "mipslab.h"  

int ADXL_VALUE=0; //This is the signal from the accelerometer

/* Wait for I2C bus to become idle. Checks if any of the ACKEN, RCEN, PEN, RSEN, SEN bits are set to 1 and if the TRSTAT bit are set to 1.
If any of the bits are set to 1, an I2C operation is in progress. If the TRSTAT bit is set a tranmit operation is in progress. */
void i2c_idle() {
	//timer4_conf(0.1);
	//timer4Start();
	int count = 0;
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14));

}

/* First, the functions checks so no other operation is on going on the i2c bus. Then it clears the ACKDT bit which is preparing the master to send an acknowledge bit to the slave.
Then it sets the ACKEN bit. This sends the previously set acknowledge bit to the slave. */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* First, the functions checks so no other operation is on going on the i2c bus. Then it sets the ACKDT bit which is preparing the master to send an not-acknowledge bit to the slave.
Then it sets the ACKEN bit. This sends the previously set not-acknowledge bit to the slave. */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Leaves the SCL signal high and pulls the SDA signal low. By that the recieving device knows a message is about to start. 
The bit generates a start condition and it is wrong to say that it is cleared but after address is sent it is "cleared"*/
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* This is a restart condition similar to the start condition. */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* The stop condition does the opposite to a start condition. */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

/*Since i2c doesn't use negative values it's most safe to use unsigned integers.
First the I2C1CON register is cleared. After that we set the Baud rate to I2C standard mode (100 kHz). A table of different hexadecimal values to set the baud rate is found in the FRS
After that the STAT register is cleared. Then it starts the I2C communication by setting the on-bit.  */
uint8_t i2c_init(void){
    uint8_t temp; 
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1 Testa att ta bort det hÃ¤r sen
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer

    return temp;
    }

/* First, check if the i2c bus is used by another i2c operation, then it send the data to the transmitt register in the i2c buss. After that tha acknowledge status is returned.
If the reciever sends an acknowledgebit the ACKSTAT bit is 0, of it is no acknowledged the ACKSTAT bit is 1.*/
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data; //The data that's transmitted
	i2c_idle();	//A very important step to make sure that the transmitt operation is finished before crecieving the acknowledgement bit
	return !(I2C1STAT & (1 << 15));
}

/* First, the recieve enable bit is set. After that the recieve register from the I2C communication is returned, */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0 TA BORT DENNA???
	return I2C1RCV;
}

/*Written by Erica*/

/*This function initializes the ADXL345 accelerometer*/
void adxl_init (void){
	/*First the ADXL345 address is sent followed by a write bit (0)
	Set enable measure by setting the measure enable bit
	The while loop wait until the acknoledgebit is recieved.*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(POWER_CTL);
    // measurer enable bit in the power control register
    i2c_send(0x08);
    i2c_stop();

	/*Send write information to the data format register about the resolution*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(DATA_FORMAT);
    i2c_send(0x0); //+-2 g resolution 10 bit mode
    i2c_stop();

/*Set the baud rate*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(BW_RATE);
    i2c_send(0x0A); // 100 Hz datarate
    i2c_stop();

/*Set offset for the y-axis*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSY);
    i2c_send(0x20); // 1 and 255. 0 is idle
    i2c_stop();

/*Set offset for the x-axis*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSX);
    i2c_send(0x10); // 
    i2c_stop();

/*Set offset for the z-axis*/
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSZ);
    i2c_send(0x6); // 
    i2c_stop();
}

/*This function recieves information from the accelerometer*/
void yaxis_data (int * data){

/*First, a write condition is sent to the accelerometer telling it that we want to access the DATAY0 register*/
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		i2c_send(DATAY0);

/*Then, a read condition is sent to the accelerometer*/
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
/*Now, we can start recieving data from the DATAY0 register*/
		*data = i2c_recv(); //LSB
/*By sending an acknowledgebit and then sending a recieve message again we automatically can read from the next register, in this case DATAY1*/
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB

/*A nack condition is sent to the slave device to tell it that we don't expect more data. After that we stop the transmission to make the I2C bus idle*/
		i2c_nack();
		i2c_stop();
/*Because our desired resolution is +-2g we need to divide it with 256 according to the data sheet.*/
		*data = *data/256;	//resolution +- 2g

}

void xaxis_data (int * data){


		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); 
		i2c_send(DATAX0);

		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); 
		

		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB

		i2c_nack();
		i2c_stop();
		*data = *data/256;	

}

void zaxis_data (int * data){

		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); 
		i2c_send(DATAZ0);

		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); 
		
		*data = i2c_recv(); 
		i2c_ack();
		*data |= i2c_recv() << 8; 

		i2c_nack();
		i2c_stop();
		*data = *data/256;

}









