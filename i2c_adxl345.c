#include <pic32mx.h>
#include <stdint.h>
#include <stdbool.h>
#include "adxl.h"


/* Wait for I2C bus to become idle */
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}//ACKEN, RCEN, PEN, RSEN, SEN



/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

uint8_t i2c_init(void){
    uint8_t temp;
	/* Set up i2c */
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer

    return temp;
    }

/* Send one byte on I2C bus, return ack/nack status of transaction */
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data; //The data that's transmitted
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/*Written by Erica*/

void adxl_init (void){
	//set measurment range
	//set output resolution
	//set sensitivity
	//set offset
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    /* Send register number we want to access */
    i2c_send(POWER_CTL);
    // measurer enable bit in the power control register
    i2c_send(0x08);
    /* Send stop condition */
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(DATA_FORMAT);
    i2c_send(0x0); //+-2 g resolution 10 bit mode
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(BW_RATE);
    i2c_send(0x0A); // 100 Hz datarate
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSY);
    i2c_send(0x20); // 1 and 255. 0 is idle
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSX);
    i2c_send(0x10); // 
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSZ);
    i2c_send(0x6); // 
    i2c_stop();
}

void yaxis_data (int * data){


		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAY0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}

void xaxis_data (int * data){

		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAX0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}

void zaxis_data (int * data){


		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAZ0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}


//Written by chat GPT, just to show the ADXL345 value to the display

#include <stdio.h>
#include <stdlib.h> // For malloc and abs

char* intToStr(int value) {
    static char str[12]; // Static storage for return value
    int i = 0;
    int isNegative = 0;

    // Handle 0 explicitly
    if (value == 0) {
        str[i++] = '0';
        str[i] = '\0';
        return str;
    }

    // Handle negative numbers
    if (value < 0) {
        isNegative = 1;
        // Special case for INT_MIN
        if (value == -2147483648) {
            value += 1; // Adjust to avoid overflow when negated
        }
        value = -value;
    }

    // Fill string with digits in reverse order
    while (value != 0) {
        int rem = value % 10;
        str[i++] = (char)(rem + '0');
        value = value / 10;
    }

    // Correct for INT_MIN adjustment
    if (isNegative && str[0] == '7') {
        str[0] = '8'; // Correct the least significant digit back to 8
    }

    // Add '-' for negative numbers
    if (isNegative) {
        str[i++] = '-';
    }

    str[i] = '\0'; // Null-terminate string

    // Reverse the string
	int start, end;
    for (start = 0, end = i - 1; start < end; start++, end--) {
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
    }

    return str;
}






