#include <pic32mx.h>
#include <stdint.h>
#include <stdbool.h>
#include "adxl.h"


/* Wait for I2C bus to become idle */
void i2c_idle() {
	while(I2C1CON & 0x1F || I2C1STAT & (1 << 14)); //TRSTAT
}//ACKEN, RCEN, PEN, RSEN, SEN



/* Send acknowledge conditon on the bus */
void i2c_ack() {
	i2c_idle();
	I2C1CONCLR = 1 << 5; //ACKDT = 0
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send not-acknowledge conditon on the bus */
void i2c_nack() {
	i2c_idle();
	I2C1CONSET = 1 << 5; //ACKDT = 1
	I2C1CONSET = 1 << 4; //ACKEN = 1
}

/* Send start conditon on the bus */
void i2c_start() {
	i2c_idle();
	I2C1CONSET = 1 << 0; //SEN
	i2c_idle();
}

/* Send restart conditon on the bus */
void i2c_restart() {
	i2c_idle();
	I2C1CONSET = 1 << 1; //RSEN
	i2c_idle();
}

/* Send stop conditon on the bus */
void i2c_stop() {
	i2c_idle();
	I2C1CONSET = 1 << 2; //PEN
	i2c_idle();
}

uint8_t i2c_init(void){
    uint8_t temp;
	/* Set up i2c */
	I2C1CON = 0x0;
	/* I2C Baud rate should be less than 400 kHz, is generated by dividing
	the 40 MHz peripheral bus clock down */
	I2C1BRG = 0x0C2;
	I2C1STAT = 0x0;
	I2C1CONSET = 1 << 13; //SIDL = 1
	I2C1CONSET = 1 << 15; // ON = 1
	temp = I2C1RCV; //Clear receive buffer

    return temp;
    }

/* Send one byte on I2C bus, return ack/nack status of transaction */
bool i2c_send(uint8_t data) {
	i2c_idle();
	I2C1TRN = data; //The data that's transmitted
	i2c_idle();
	return !(I2C1STAT & (1 << 15)); //ACKSTAT
}

/* Receive one byte from I2C bus */
uint8_t i2c_recv() {
	i2c_idle();
	I2C1CONSET = 1 << 3; //RCEN = 1
	i2c_idle();
	I2C1STATCLR = 1 << 6; //I2COV = 0
	return I2C1RCV;
}

/*Written by Erica*/

void adxl_init (void){
	//set measurment range
	//set output resolution
	//set sensitivity
	//set offset
	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    /* Send register number we want to access */
    i2c_send(POWER_CTL);
    // measurer enable bit in the power control register
    i2c_send(0x08);
    /* Send stop condition */
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(DATA_FORMAT);
    i2c_send(0x0); //+-2 g resolution 10 bit mode
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(BW_RATE);
    i2c_send(0x0A); // 100 Hz datarate
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSY);
    i2c_send(0x20); // 1 and 255. 0 is idle
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSX);
    i2c_send(0x10); // 
    i2c_stop();

	do {
		i2c_start();
	} while(!i2c_send(ADXL345_ADDRESS << 1));
    i2c_send(OFSZ);
    i2c_send(0x6); // 
    i2c_stop();
}

void yaxis_data (int * data){


		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAY0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}

void xaxis_data (int * data){

		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAX0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}

void zaxis_data (int * data){


		/* Send start condition and address of the accelerometer with
		write flag (lowest bit = 0) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send(ADXL345_ADDRESS << 1)); // 0 write mode
		/* Send register number we want to access */
		i2c_send(DATAZ0);

		/* Now send another start condition and address of the accelerometer with
		read mode (lowest bit = 1) until the accelerometer sends
		acknowledge condition */
		do {
			i2c_start();
		} while(!i2c_send((ADXL345_ADDRESS << 1) | 1)); //1 read mode
		
		/* Now we can start receiving data from the accelerometer DATAX0 and then DATAX1 */
		*data = i2c_recv(); //LSB
		i2c_ack();
		*data |= i2c_recv() << 8; //MSB
		//When you send to revieve messages after each other without a stop condition you automatically read from two addresses after each other.

		/* To stop receiving, send nack and stop */
		i2c_nack();
		i2c_stop();
		*data = *data/256;	//resolution +- 2g

}


/*Written by chat GPT, just to show the ADXL345 value to the display*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

size_t my_strlen(const char* str) {
    const char* s;
    for (s = str; *s; ++s) {}
    return (s - str);
}

// Utility function to reverse a string
void reverse(char* str) {
    int len = my_strlen(str);
	int i;
    for (i = 0; i < len / 2; i++) {
        char temp = str[i];
        str[i] = str[len - i - 1];
        str[len - i - 1] = temp;
    }
}

// Function to convert a decimal number to a string
void decimalToString(int number, char* str) {
    int i = 0;
    int isNegative = 0;

    // Handle 0 explicitly
    if (number == 0) {
        str[i++] = '0';
        str[i] = '\0';
        return;
    }

    // Check for negative numbers
    if (number < 0) {
        isNegative = 1;
        number = -number;
    }

    // Process individual digits
    while (number != 0) {
        int rem = number % 10;
        str[i++] = rem + '0';
        number = number / 10;
    }

    // If number is negative, append '-'
    if (isNegative)
        str[i++] = '-';

    str[i] = '\0'; // Append string terminator

    // Reverse the string
    reverse(str);
}

// Function to convert two's complement hexadecimal to decimal
int hexToDecimal(int hex) {
    // Assuming int is 32 bits, check if the hexadecimal number is negative
    if (hex & 0x80000000) {
        // If negative, calculate two's complement
        return -((~hex + 1) & 0xFFFFFFFF);
    } else {
        // If positive, return it as is
        return hex;
    }
}

// Main function to convert hex to string
void hexToString(int hex, char* str) {
    int decimal = hexToDecimal(hex);
    decimalToString(decimal, str);
}







